#include <cstdint>
#include <cstddef>
#include <cstring>

extern "C" {
#include "rmw_microros/rmw_microros.h"
#include "uxr/client/profile/transport/custom/custom_transport.h"
}

#include "STM32Hardware.h"

/*
 * External symbols generated by CubeMX / main.c
 * These must be created before microros_transport_init() is called.
 */
extern UART_HandleTypeDef huart1;
extern osMutexId rosPubMutexHandle;
extern osSemaphoreId uartTxSemHandle;

struct TransportContext
{
  STM32Hardware hw;
};

static TransportContext g_transport;

/**
 * @brief Open custom transport.
 *
 * Initializes STM32Hardware in RTOS + DMA mode.
 */
static bool transport_open(struct uxrCustomTransport * /*transport*/)
{
  g_transport.hw.deinit();
  g_transport.hw.init(&huart1, &rosPubMutexHandle, &uartTxSemHandle);
  return true;
}

/**
 * @brief Close custom transport.
 *
 * No explicit deinitialization is required for this project.
 */
static bool transport_close(struct uxrCustomTransport * /*transport*/)
{
  g_transport.hw.deinit();
  return true;
}

/**
 * @brief Read bytes from UART transport.
 *
 * NOTE: In some Micro XRCE-DDS versions, the custom read function includes
 * an extra `err` output parameter. This implementation matches that signature.
 *
 * @param transport   Unused
 * @param buf         Destination buffer
 * @param len         Maximum bytes to read
 * @param timeout_ms  Timeout in milliseconds (-1: infinite, 0: non-blocking)
 * @param err         Transport error output (optional, may be unused)
 * @return Number of bytes actually read
 */
static size_t transport_read(struct uxrCustomTransport * /*transport*/,
                             uint8_t *buf,
                             size_t len,
                             int timeout_ms,
                             uint8_t * /*err*/)
{
  size_t count = 0;
  uint32_t start_tick = HAL_GetTick();

  while (count < len)
  {
    int c = g_transport.hw.read();
    if (c >= 0)
    {
      buf[count++] = static_cast<uint8_t>(c);
      continue;
    }

    /* No data available */
    if (timeout_ms == 0)
    {
      break;
    }

    if (timeout_ms > 0 &&
        static_cast<int>(HAL_GetTick() - start_tick) >= timeout_ms)
    {
      break;
    }

    /* Yield CPU in RTOS environment */
    osDelay(1);
  }

  return count;
}

/**
 * @brief Write bytes to UART transport (blocking).
 *
 * Stability-first design:
 *  - Enqueue data into STM32Hardware TX queue
 *  - Start DMA transmissions and wait for completion via semaphore
 *  - Return only after all bytes are physically transmitted
 *
 * @param transport Unused
 * @param buf       Data buffer
 * @param len       Number of bytes to send
 * @param err       Transport error output (optional, may be unused)
 * @return Number of bytes written
 */
static size_t transport_write(struct uxrCustomTransport * /*transport*/,
                              const uint8_t *buf,
                              size_t len,
                              uint8_t * /*err*/)
{
  size_t sent = 0;

  while (sent < len)
  {
    /* Chunk size is arbitrary; STM32Hardware splits into TX_BUFFER_WIDTH internally */
    const size_t chunk = (len - sent > 1024) ? 1024 : (len - sent);

    g_transport.hw.write(
        const_cast<uint8_t*>(buf + sent),
        static_cast<uint16_t>(chunk));

    /* Flush TX queue until empty */
    while (true)
    {
      const int status = g_transport.hw.publish();
      if (status == BUFFER_EMPTY)
      {
        break;
      }
      /* HAL_OK or error both can lead to semaphore release via callbacks.
         Stability-first: keep flushing. */
      osDelay(1);
    }

    sent += chunk;
  }

  return sent;
}

/**
 * @brief Register STM32 custom transport to micro-ROS.
 *
 * Must be called before rclc_support_init().
 */
extern "C" void microros_transport_init(void)
{
  rmw_uros_set_custom_transport(
      true,                   /* use custom transport */
      nullptr,                /* user argument (unused) */
      transport_open,
      transport_close,
      transport_write,
      transport_read);
}
